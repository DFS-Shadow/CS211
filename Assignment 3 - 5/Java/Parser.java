/******************************************************************************
* Parser.java
*	The `Parser` class processes tokens generated by a Tokenizer into an
*	evaluable expression.
*
******************************************************************************/
public class Parser {
	/**************************************************************************
	*
	*	Constructors
	*
	**************************************************************************/
	public Parser(String expression) {
		m_operatorStack = new Stack<>();
		m_outputStack = new Stack<>();
		// Create the tokenizer to use
		m_tokenizer = new Tokenizer(expression);
		// Loop until all tokens have been extracted
		while (m_tokenizer.hasNext()) {
			// Get the current token
			IToken token = m_tokenizer.getNextToken();
			// Dispatch the token to the correct processing function
			if (token instanceof Constant) {
				processToken((Constant)token);
			} else if (token instanceof Operator) {
				processToken((Operator)token);
			} else if (token instanceof Fence) {
				processToken((Fence)token);
			} else if (token instanceof PopFence) {
				processToken((PopFence)token);
			}
		}

		// Process any remaining tokens
		clearOperatorStack();
		// If any tokens remain, then a fence-mismatch occurred
		if (!m_operatorStack.isEmpty()) {
			// Output the fence mismatch - no closing fence error message
			m_tokenizer.printErrorMessage(1);
		}

		// Check the number of tokens within the output stack
		// If more than one exist, the expression is ill-formed
		if (m_outputStack.size() > 1 || m_outputStack.size() == 0) {
			// Output an error message - Ill-formed expression
			m_tokenizer.printErrorMessage(0,
				"Tokens remaining: " + m_outputStack.size() +
				" (should be 1)");
		}

		// If all above checks passed, link the root token variable
		m_root = m_outputStack.pop();
	}

	/**************************************************************************
	*
	*	Public Member Functions
	*
	**************************************************************************/
	/// @brief Evaluates the expression.
	public float evaluate() {
		return m_root.evaluate();
	}

	/// @brief Checks if the parser produced a valid expression.
	public boolean isValid() {
		return m_tokenizer.getErrorCount() == 0;
	}

	public int getErrorCount() {
		return m_tokenizer.getErrorCount();
	}

	/// @brief Returns the given expression in postfix notation.
	public String getPostfixExpression() {
		return m_root.toString();
	}

	/**************************************************************************
	*
	*	Private Member Functions
	*
	**************************************************************************/
	/// @brief Clears the operators stack.
	/// @details This overload stops as soon as a fence is hit.
	void clearOperatorStack() {
		// Continue until either all operators have been removed or a fence
		// is met.
		// This condition statement uses short circuit evaluation to ensure
		// that the call to `peek()` is valid
		while (!m_operatorStack.isEmpty() &&
			!(m_operatorStack.peek() instanceof Fence)) {
			m_outputStack.push(linkTokens((Operator)m_operatorStack.pop()));
		}
	}

	/// @brief Clears the operator stack.
	/// @details This overload pops operators until a fence is hit, then
	///		verifies that the encountered fence is of the expected type.
	void clearOperatorStack(PopFence fence) {
		// Call the non-pop-fence overload
		// This will clear the stack up until the first fence
		clearOperatorStack();
		// If the operators stack is empty, the expression is not valid
		if (m_operatorStack.isEmpty()) {
			// Output an error message -
			// Mismatched fence - no opening fence found
			m_tokenizer.printErrorMessage(2);
		}

		// Get the fence operator
		Fence openingFence = (Fence)m_operatorStack.peek();
		// Verify that the fences match
		if (!openingFence.isValidClosingFence(fence)) {
			// Output an error message -
			// Mismatched fences - opening fence does not match closing fence
			m_tokenizer.printErrorMessage(3, "Expected \"" +
				openingFence.getClosingChar() + "\"; Got \"" +
				fence.getFenceChar() + "\".");
		}

		// If the above check passes, remove the fence from the stack
		m_operatorStack.pop();
	}

	/// @brief Links tokens from the output stack to the provided token.
	/// @returns Returns a reference to the operator passed to the function
	///		for convenience.
	IEvaluable linkTokens(Operator operator) {
		// All operators take two arguments
		for (int i = 1; i >= 0; --i) {
			if (m_outputStack.isEmpty()) {
				// Output an error message:
				// Not enough input tokens
				m_tokenizer.printErrorMessage(4, "Expected two operands.");
				break;
			}

			IEvaluable evaluable = m_outputStack.pop();
			operator.bindInputToken(i, evaluable);
		}

		return operator;
	}

	void processToken(Constant token) {
		// Constants are simply pushed to the output stack
		m_outputStack.push(token);
	}

	void processToken(Operator operator) {
		// If the operator stack is empty, simply push the operator
		// to the stack
		if (m_operatorStack.isEmpty()) {
			m_operatorStack.push(operator);
			return;
		}

		// If the operator stack contains at least one object, get a reference
		// to it and determine how to proceed
		IToken token = m_operatorStack.peek();
		// If the token is a fence object, just push the operator to the stack
		if (token instanceof Fence) {
			m_operatorStack.push(operator);
			return;
		}
		// At this point, the token must be an operator
		Operator topOperator = (Operator)token;
		// If the current operator's precedence is equal to or higher
		// than the operator on the stack, push the operator to the stack
		if (operator.getPrecedence() >= topOperator.getPrecedence()) {
			m_operatorStack.push(operator);
			return;
		}

		// If the current operator's precedence is lower than the top
		// operator's precedence, pop all operators from the stack
		clearOperatorStack();
		// Add the operator to the stack
		m_operatorStack.push(operator);
	}

	void processToken(Fence fence) {
		// Push the fence onto the operator stack
		m_operatorStack.push(fence);
	}

	void processToken(PopFence fence) {
		// Pop tokens from the stack until a fence is met
		clearOperatorStack(fence);
	}

	/**************************************************************************
	*
	*	Private Member Variables
	*
	**************************************************************************/
	/// @brief Root node used to evaluate the entire expression.
	private IEvaluable m_root;
	/// @brief Tokenizer used for processing the expression.
	private Tokenizer m_tokenizer;
	/// @brief Stack used for storing operators during token processing.
	/// @details Tokens in this stack will either be `Fence` objects or
	///		`Operator` objects.
	private Stack<IToken> m_operatorStack;
	/// @brief Stack used for storing tokens during token processing.
	private Stack<IEvaluable> m_outputStack;
}