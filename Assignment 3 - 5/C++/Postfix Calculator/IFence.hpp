/******************************************************************************
* IFence.hpp
*	`IFence`-derived objects are used to "fence off" operators on the operator
*	stack. Fences allow operators to be evaluated out of order, such as when
*	parentheses are used in an infix-notation expression.
*
******************************************************************************/
#pragma once

#include <string>

#include "IToken.hpp"
#include "IPopFence.hpp"

class IFence : public IToken
{
public:
	/// @brief Standard constructor.
	/// @details The Fence class requires the string representation of the
	///		token to be passed to it so that Evaluators can verify that a
	///		pop fence token matches the first stored fence.
	/// @param closingFenceToken String representation of the closing fence token.
	IFence(std::string closingFenceToken);
	virtual ~IFence() = default;
	/// @brief Returns the string representation of the closing fence token
	///		associated with this fence.
	const std::string& getClosingFenceToken() const;

private:
	/// @brief Stores the closing fence token for this fence.
	const std::string m_closingFenceToken;
};

/// @brief Macro used for generating an `IFence`-derived class.
/// @details This macro also generates an associated `IPopFence`-derived
///		class.
/// @remarks Each of the autogenerated classes is able to accept any number
///		of arguments (of one type), as the `RegexParser` class passes all
///		matched strings to the constructor of the object it is creating.
/// @param Name Name to use for the Fence class. This will have "Fence"
///		appended to it.
/// @param ClosingToken Token used to pop the fence from the stack. Must be
///		enclosed in quotation marks.
#define GENERATE_FENCE_CLASS(Name, ClosingToken)							\
class Name##Fence : public IFence											\
{																			\
public:																		\
	template <typename... Ts>												\
	Name##Fence(const Ts&...) :												\
		IFence(ClosingToken)												\
	{																		\
																			\
	}																		\
};																			\
																			\
class Name##PopFence : public IPopFence										\
{																			\
public:																		\
	template <typename... Ts>												\
	Name##PopFence(const Ts&...) :											\
		IPopFence(ClosingToken)												\
	{																		\
																			\
	}																		\
};