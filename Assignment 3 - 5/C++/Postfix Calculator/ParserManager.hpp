/**************************************************************************//**
* ParserManager.hpp
*	Singleton class used to manage `IParser`-derived classes.
*
******************************************************************************/
#pragma once

#include <memory>
#include <vector>

#include "IParser.hpp"
#include "IToken.hpp"

class ParserManager
{
public:
	/// @brief Retrieves the singleton.
	static ParserManager& getSingleton();
	/// @brief Parses an expression and returns tokens generated by parsers.
	/// @details The `expression` string will be modified by the parser that
	///		extracts tokens from the expression.
	/// @param expression Infix-notation expression to be parsed.
	std::vector<std::unique_ptr<IToken>> parseExpression(
		std::string& expression);
	/// @brief Registers a parser with the singleton.
	template <typename Parser>
	void registerParser()
	{
		m_parsers.emplace_back(std::unique_ptr<IParser>(new Parser()));
	}

private:
	/// @brief Standard private constructor for Singletons.
	ParserManager() = default;
	/// @brief Removes any leading whitespace from the string.
	/// @param str String to remove whitespace from.
	void removeLeadingWhitespace(std::string& str);

	/// @brief Vector containing all registered parsers.
	std::vector<std::unique_ptr<IParser>> m_parsers;
};

/// @brief Helper struct used with the `REGISTER_PARSER()` macro for automatic
///		parser registration.
template <typename Parser>
struct RegisterParser
{
	/// @brief Standard constructor.
	RegisterParser()
	{
		ParserManager::getSingleton().registerParser<Parser>();
	}
};

/// @brief Macro used to autoregister a parser.
/// @param ParserClass Name of the Parser class to register.
#define REGISTER_PARSER(ParserClass)										\
namespace ParserClass##Detail {												\
	static const RegisterParser<ParserClass> autoregister;					\
}