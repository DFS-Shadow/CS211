/******************************************************************************
* RegexParser.hpp
*	The `RegexParser` class is a templated type that can be extended with
*	minimal effort to implement a parser that utilizes regexes to extract
*	tokens from a string.
*
******************************************************************************/
#pragma once

#include <cassert>
#include <memory>
#include <regex>
#include <string>
#include <vector>

#include "IParser.hpp"
#include "ParserManager.hpp"
#include "type_at_index.hpp"

/// @param TokenClasses Specifies the token classes to generate from a parsed
///		expression. Each regex group is mapped to a Token class - ie group 0
///		is passed to the constructor of the first token class specified in the
///		`TokenClasses` variadic template argument.
template <typename... TokenClasses>
class RegexParser : public IParser
{
public:
	/// @brief Standard Constructor.
	/// @param priority Priority level of the parser.
	/// @param pattern Regex pattern to use.
	RegexParser(int32_t priority, const std::string& pattern) :
		IParser(priority),
		m_regex(pattern)
	{

	}
	/// @brief Parses the string and extracts tokens from the expression, if
	///		possible.
	/// @details If the parser is unable to extract tokens from the expression,
	///		the expression string will remain unmodified. If the parser is
	///		able to extract tokens, the parser will remove the associated
	///		characters from the string.
	/// @returns Returns a vector containing any extracted tokens.
	virtual std::vector<std::unique_ptr<IToken>> parse(
		std::string& expression) override
	{
		// Vector to return
		std::vector<std::unique_ptr<IToken>> retVal;
		// Apply the regex to the expression
		std::smatch matches;
		// If no matches are found, return the empty vector
		if (!std::regex_search(expression, matches, m_regex))
		{
			return retVal;
		}
		// If matches are found, process them and generate `IToken`-derived
		// objects
		assert(matches.size() == TOKEN_CLASS_COUNT);
		processMatches<0>(retVal, matches);
		// Remove the characters that were matched
		size_t charsProcessed = matches[0].length();
		expression = expression.substr(charsProcessed);
		return retVal;
	}

private:
	/// @brief Recursive template function used for generating tokens from
	///		regex matches.
	template <size_t Index>
	void processMatches(std::vector<std::unique_ptr<IToken>>& retVal,
		const std::smatch& matches)
	{
		// Token class to use for this index
		using TokenClass = type_at_index_t<Index, TokenClasses...>;
		// Get the string representation of the parsed expression
		const std::string match = matches[Index].str();
		// Construct the token
		auto ptr = std::make_unique<TokenClass>(match);
		retVal.emplace_back(std::move(ptr));
		// If additional matches should exist, call this function again
		if constexpr(Index + 1 < TOKEN_CLASS_COUNT)
		{
			processMatches<Index + 1>(retVal, matches);
		}
	}

	/// @brief Stores the number of token classes provided.
	static const size_t TOKEN_CLASS_COUNT = sizeof...(TokenClasses);
	/// @brief Stores the regex object used for parsing the string.
	std::regex m_regex;
};

/// @brief Generates a class based on the Regex Parser class.
/// @param Name Name of the parser to create. The generated parser name will
///		be this name plus "Parser" appended to the name.
/// @param Pattern Regex pattern to use for parsing.
/// @param Priority Priority level of the parser.
/// @param ... Token classes to be generated by the Parser. See the
///		`RegexParser` documentation for the `TokenClasses` variadic template
///		argument.
#define GENERATE_REGEX_PARSER(Name, Pattern, Priority, ...)					\
class Name##Parser : public RegexParser<__VA_ARGS__>						\
{																			\
public:																		\
	Name##Parser() :														\
		RegexParser(Priority, Pattern)										\
	{																		\
																			\
	}																		\
};																			\
REGISTER_PARSER(Name##Parser)